import { noop, once, hasOwn, partitionObject, generateRandomId } from '@livechat/data-utils';
import _extends from '@babel/runtime/helpers/esm/extends';
import promiseTry from '@livechat/promise-try';
import mitt from '@livechat/mitt';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { removeNode } from '@livechat/dom-utils';

/**
 * callbag-map
 * -----------
 *
 * Callbag operator that applies a transformation on data passing through it.
 * Works on either pullable or listenable sources.
 *
 * `npm install callbag-map`
 *
 * Example:
 *
 *     const fromIter = require('callbag-from-iter');
 *     const iterate = require('callbag-iterate');
 *     const map = require('callbag-map');
 *
 *     const source = map(x => x * 0.1)(fromIter([10,20,30,40]));
 *
 *     iterate(x => console.log(x))(source); // 1
 *                                           // 2
 *                                           // 3
 *                                           // 4
 */
var map = function map(f) {
  return function (source) {
    return function (start, sink) {
      if (start !== 0) return;
      source(0, function (t, d) {
        sink(t, t === 1 ? f(d) : d);
      });
    };
  };
};

var readme = map;

function last(source) {
  return function (start, sink) {
    if (start !== 0) return;
    var gotValue = false;
    var disposed = false;
    var talkback;
    var value;
    source(0, function (type, data) {
      if (type === 0) {
        talkback = data;
        sink(0, function (type, data) {
          if (type === 2) {
            disposed = true;
          }

          talkback(type, data);
        });
        return;
      }

      if (type === 1) {
        gotValue = true;
        value = data;
        talkback(1);
        return;
      }

      if (type === 2 && !data && gotValue) {
        sink(1, value);

        if (disposed) {
          return;
        }
      }

      sink(type, data);
    });
  };
}

var subscribe = function subscribe(listener) {
  if (listener === void 0) {
    listener = {};
  }

  return function (source) {
    if (typeof listener === "function") {
      listener = {
        next: listener
      };
    }

    var _listener = listener,
        next = _listener.next,
        error = _listener.error,
        complete = _listener.complete;
    var talkback;
    source(0, function (t, d) {
      if (t === 0) {
        talkback = d;
      }

      if (t === 1 && next) next(d);
      if (t === 1 || t === 0) talkback(1); // Pull

      if (t === 2 && !d && complete) complete();
      if (t === 2 && !!d && error) error(d);
    });

    var dispose = function dispose() {
      if (talkback) talkback(2);
    };

    return dispose;
  };
};

function toPromise(source) {
  return new Promise(function (resolve, reject) {
    subscribe({
      next: resolve,
      error: reject,
      complete: function complete() {
        var err = new Error('No elements in sequence.');
        err.code = 'NO_ELEMENTS';
        reject(err);
      }
    })(last(source));
  });
}

/**
 * callbag-filter
 * --------------
 *
 * Callbag operator that conditionally lets data pass through. Works on either
 * pullable or listenable sources.
 *
 * `npm install callbag-filter`
 *
 * Example:
 *
 *     const fromIter = require('callbag-from-iter');
 *     const iterate = require('callbag-iterate');
 *     const filter = require('callbag-filter');
 *
 *     const source = filter(x => x % 2)(fromIter([1,2,3,4,5]));
 *
 *     iterate(x => console.log(x))(source); // 1
 *                                           // 3
 *                                           // 5
 */
var filter = function filter(condition) {
  return function (source) {
    return function (start, sink) {
      if (start !== 0) return;
      var talkback;
      source(0, function (t, d) {
        if (t === 0) {
          talkback = d;
          sink(t, d);
        } else if (t === 1) {
          if (condition(d)) sink(t, d);else talkback(1);
        } else sink(t, d);
      });
    };
  };
};

var readme$1 = filter;

/**
 * callbag-for-each
 * ----------------
 *
 * Callbag sink that consume both pullable and listenable sources. When called
 * on a pullable source, it will iterate through its data. When called on a
 * listenable source, it will observe its data.
 *
 * `npm install callbag-for-each`
 *
 * Examples
 * --------
 *
 * Consume a pullable source:
 *
 *     const fromIter = require('callbag-from-iter');
 *     const forEach = require('callbag-for-each');
 *
 *     const source = fromIter([10,20,30,40])
 *
 *     forEach(x => console.log(x))(source); // 10
 *                                           // 20
 *                                           // 30
 *                                           // 40
 *
 * Consume a listenable source:
 *
 *     const interval = require('callbag-interval');
 *     const forEach = require('callbag-for-each');
 *
 *     const source = interval(1000);
 *
 *     forEach(x => console.log(x))(source); // 0
 *                                           // 1
 *                                           // 2
 *                                           // 3
 *                                           // ...
 */
var forEach = function forEach(operation) {
  return function (source) {
    var talkback;
    source(0, function (t, d) {
      if (t === 0) talkback = d;
      if (t === 1) operation(d);
      if (t === 1 || t === 0) talkback(1);
    });
  };
};

var readme$2 = forEach;

function retry(max) {
  if (max === void 0) {
    max = -1;
  }

  return function (source) {
    return function (start, sink) {
      if (start !== 0) return;
      var inited = false;
      var retries = max;
      var sourceTalkback;

      var talkback = function talkback(type, data) {
        sourceTalkback(type, data);
      };

      var subscribe = function subscribe() {
        source(0, function (type, data) {
          if (type === 0) {
            sourceTalkback = data;

            if (inited) {
              // this pull probably shouldn't be unconditional
              // but I'm not sure how to track if we should pull or not at the moment
              talkback(1);
              return;
            }

            inited = true;
            sink(0, talkback);
            return;
          }

          if (type === 2 && data) {
            if (retries !== 0) {
              retries--;
              subscribe();
              return;
            }
          }

          sink(type, data);
        });
      };

      subscribe();
    };
  };
}

var share = function share(source) {
  var sinks = [];
  var sourceTalkback;
  return function shared(start, sink) {
    if (start !== 0) return;
    sinks.push(sink);

    var talkback = function talkback(t, d) {
      if (t === 2) {
        var i = sinks.indexOf(sink);
        if (i > -1) sinks.splice(i, 1);
        if (!sinks.length) sourceTalkback(2);
      } else {
        sourceTalkback(t, d);
      }
    };

    if (sinks.length === 1) {
      source(0, function (t, d) {
        if (t === 0) {
          sourceTalkback = d;
          sink(0, talkback);
        } else {
          for (var _iterator = sinks.slice(0), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var s = _ref;
            s(t, d);
          }
        }

        if (t === 2) sinks = [];
      });
      return;
    }

    sink(0, talkback);
  };
};

var take = function take(max) {
  return function (source) {
    return function (start, sink) {
      if (start !== 0) return;
      var taken = 0;
      var sourceTalkback;

      function talkback(t, d) {
        if (taken < max) sourceTalkback(t, d);
      }

      source(0, function (t, d) {
        if (t === 0) {
          sourceTalkback = d;
          sink(0, talkback);
        } else if (t === 1) {
          if (taken < max) {
            taken++;
            sink(t, d);

            if (taken === max) {
              sink(2);
              sourceTalkback(2);
            }
          }
        } else {
          sink(t, d);
        }
      });
    };
  };
};

var callbagTake = take;

var UNIQUE = {};

var takeUntil = function takeUntil(sSrc) {
  return function (src) {
    return function (start, sink) {
      if (start !== 0) return;
      var sourceTalkback;
      var sTalkback;
      var inited = false;
      var done = UNIQUE;
      src(0, function (t, d) {
        if (t === 0) {
          sourceTalkback = d;
          sSrc(0, function (st, sd) {
            if (st === 0) {
              sTalkback = sd;
              sTalkback(1);
              return;
            }

            if (st === 1) {
              done = undefined;
              sTalkback(2);
              sourceTalkback(2);
              inited && sink(2);
              return;
            }

            if (st === 2) {
              sTalkback = null;

              if (sd) {
                done = sd;
                sourceTalkback(2);
                inited && sink(st, sd);
              }
            }
          });
          inited = true;
          sink(0, function (st, sd) {
            if (done !== UNIQUE) return;
            if (st === 2 && sTalkback) sTalkback(2);
            sourceTalkback(st, sd);
          });
          if (done !== UNIQUE) sink(2, done);
          return;
        }

        if (t === 2) sTalkback(2);
        sink(t, d);
      });
    };
  };
};

function timeout(delay) {
  return function (source) {
    return function (start, sink) {
      if (start !== 0) return;
      var absoluteDelay = delay instanceof Date;
      var talkback;
      var timerId;

      function scheduleTimeout(ms) {
        timerId = setTimeout(function () {
          talkback(2);
          var err = new Error('Timeout.');
          err.code = 'TIMEOUT';
          sink(2, err);
        }, ms);
      }

      source(0, function (type, data) {
        if (type === 0) {
          talkback = data;
          scheduleTimeout(absoluteDelay ? delay - Date.now() : delay);
          sink(0, function (type, data) {
            if (type === 2) {
              clearTimeout(timerId);
            }

            talkback(type, data);
          });
          return;
        }

        if (type === 2) {
          clearTimeout(timerId);
        } else if (type === 1 && !absoluteDelay) {
          clearTimeout(timerId);
          scheduleTimeout(delay);
        }

        sink(type, data);
      });
    };
  };
}

var CALL = 'call';
var EMIT = 'emit';
var FINGERPRINT = '@@livechat/postmessenger';
var HANDSHAKE = 'handshake';
var RESPONSE = 'response';

var flatten = function flatten(source) {
  return function (start, sink) {
    if (start !== 0) return;
    var outerEnded = false;
    var outerTalkback;
    var innerTalkback;

    function talkback(t, d) {
      if (t === 1) (innerTalkback || outerTalkback)(1, d);

      if (t === 2) {
        innerTalkback && innerTalkback(2);
        outerTalkback(2);
      }
    }

    source(0, function (T, D) {
      if (T === 0) {
        outerTalkback = D;
        sink(0, talkback);
      } else if (T === 1) {
        var innerSource = D;
        innerTalkback && innerTalkback(2);
        innerSource(0, function (t, d) {
          if (t === 0) {
            innerTalkback = d;
            innerTalkback(1);
          } else if (t === 1) sink(1, d);else if (t === 2 && d) {
            outerTalkback(2);
            sink(2, d);
          } else if (t === 2) {
            if (outerEnded) sink(2);else {
              innerTalkback = void 0;
              outerTalkback(1);
            }
          }
        });
      } else if (T === 2 && D) {
        innerTalkback && innerTalkback(2);
        sink(2, D);
      } else if (T === 2) {
        if (!innerTalkback) sink(2);else outerEnded = true;
      }
    });
  };
};

var lazy = function lazy(f) {
  return function (start, sink) {
    if (start === 0) {
      var unsubed = false;
      sink(0, function (type) {
        if (type === 2) unsubed = true;
      });
      sink(1, f());
      if (!unsubed) sink(2);
    }
  };
};

var defer = function defer(factory) {
  return flatten(lazy(factory));
};

var lazy$1 = function lazy(f) {
  return function (start, sink) {
    if (start === 0) {
      var unsubed = false;
      sink(0, function (type) {
        if (type === 2) unsubed = true;
      });
      sink(1, f());
      if (!unsubed) sink(2);
    }
  };
};

function throwError(error) {
  return function (start, sink) {
    if (start !== 0) return;
    var disposed = false;
    sink(0, function (end) {
      if (end !== 2) return;
      disposed = true;
    });
    if (disposed) return;
    sink(2, error || new Error());
  };
}

var fromEvent = function fromEvent(node, name, options) {
  return function (start, sink) {
    if (start !== 0) return;
    var disposed = false;

    var handler = function handler(ev) {
      sink(1, ev);
    };

    sink(0, function (t) {
      if (t !== 2) {
        return;
      }

      disposed = true;
      node.removeEventListener(name, handler, options);
    });

    if (disposed) {
      return;
    }

    node.addEventListener(name, handler, options);
  };
};

/**
 * callbag-merge
 * -------------
 *
 * Callbag factory that merges data from multiple callbag sources. Works well
 * with listenable sources, and while it may work for some pullable sources,
 * it is only designed for listenable sources.
 *
 * `npm install callbag-merge`
 *
 * Example:
 *
 *     const interval = require('callbag-interval');
 *     const forEach = require('callbag-for-each');
 *     const merge = require('callbag-merge');
 *
 *     const source = merge(interval(100), interval(350));
 *
 *     forEach(x => console.log(x))(source); // 0
 *                                           // 1
 *                                           // 2
 *                                           // 0
 *                                           // 3
 *                                           // 4
 *                                           // 5
 *                                           // ...
 */
function merge() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  return function (start, sink) {
    if (start !== 0) return;
    var n = sources.length;
    var sourceTalkbacks = new Array(n);
    var startCount = 0;
    var endCount = 0;

    var talkback = function talkback(t) {
      if (t === 0) return;

      for (var i = 0; i < n; i++) {
        sourceTalkbacks[i] && sourceTalkbacks[i](t);
      }
    };

    var _loop = function _loop(i) {
      sources[i](0, function (t, d) {
        if (t === 0) {
          sourceTalkbacks[i] = d;
          if (++startCount === 1) sink(0, talkback);
        } else if (t === 2) {
          sourceTalkbacks[i] = void 0;
          if (++endCount === n) sink(2);
        } else sink(t, d);
      });
    };

    for (var i = 0; i < n; i++) {
      _loop(i);
    }
  };
}

var readme$3 = merge;

var sanitizeEvent = (function (event) {
  return !!event.data && event.data[FINGERPRINT];
});

var getDocumentReady$ = function getDocumentReady$() {
  return share(readme$1(function () {
    return document.readyState === 'complete';
  })(readme$3( // just trigger a single emit so filter downstream can check if the document is ready
  lazy$1(noop), fromEvent(document, 'readystatechange'))));
};
var getWindowMessage$ =
/*#__PURE__*/
once(function () {
  return share(readme(function (event) {
    event.data.origin = event.origin;
    return event.data;
  })(readme$1(sanitizeEvent)(fromEvent(window, 'message'))));
});
function switchMap(project) {
  return function (source) {
    return flatten(readme(project)(source));
  };
}

var requestCounter = 0;
var makeRequest = (function (ownMessage$, postMessage, payload, request) {
  if (request === void 0) {
    request = requestCounter++;
  }

  return defer(function () {
    payload.request = request;
    postMessage(payload);
    return callbagTake(1)(switchMap(function (message) {
      if (!message.data.error) {
        // should be of(message.data.result), but don't want to add extra dependency
        // lazy is already dependency of defer
        return lazy$1(function () {
          return message.data.result;
        });
      }

      var _message$data$result = message.data.result,
          real = _message$data$result.real,
          error = _message$data$result.error;

      if (!real) {
        return throwError(error);
      }

      var err = new Error(error.message);

      if (hasOwn('code', error)) {
        err.code = error.code;
      }

      return throwError(err);
    })(readme$1(function (message) {
      return message.type === RESPONSE && message.request === request;
    })(ownMessage$)));
  });
});

var createApi = (function (emitter, ownMessage$, createMessage, postMessage, data) {
  if (data === void 0) {
    data = null;
  }

  return _extends({}, emitter, {
    call: function call(method) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return toPromise(makeRequest(ownMessage$, postMessage, createMessage(CALL, {
        method: method,
        args: args
      })));
    },
    emit: function emit(event, arg) {
      postMessage(createMessage(EMIT, {
        event: event,
        arg: arg
      }));
    },
    data: data
  });
});

function makeSubject() {
  var sinks = [];
  return function (type, data) {
    if (type === 0) {
      var sink = data;
      sinks.push(sink);
      sink(0, function (t) {
        if (t === 2) {
          var i = sinks.indexOf(sink);
          if (i > -1) sinks.splice(i, 1);
        }
      });
    } else {
      var zinkz = sinks.slice(0);

      for (var i = 0, n = zinkz.length, _sink; i < n; i++) {
        _sink = zinkz[i];
        if (sinks.indexOf(_sink) > -1) _sink(type, data);
      }
    }
  };
}

var callbagSubject = makeSubject;

function createDestroyPair() {
  var destroy$ = callbagSubject();

  var destroy = function destroy() {
    var error = new Error('Destroyed.');
    error.code = 'DESTROYED';
    destroy$(2, error);
  };

  return [destroy$, destroy];
}

var _createMessage = (function (owner, instance, type, data) {
  var _ref;

  return _ref = {}, _ref[FINGERPRINT] = true, _ref.owner = owner, _ref.instance = instance, _ref.type = type, _ref.data = data, _ref;
});

var createMessageHandler = (function (api, emit, postMessage, methods) {
  return function (message) {
    switch (message.type) {
      case CALL:
        promiseTry(function () {
          var _message$data = message.data,
              method = _message$data.method,
              args = _message$data.args;
          var fn = methods[method];
          return fn.apply(api, args);
        }).then(function (result) {
          // recycle existing object
          message.type = RESPONSE;
          message.data = {
            error: false,
            result: result
          };
          postMessage(message);
        }, function (error) {
          // recycle existing object
          message.type = RESPONSE;
          var result;

          if (error instanceof Error) {
            result = {
              real: true,
              error: {
                message: error.message
              }
            };

            if (hasOwn('code', error)) {
              result.error.code = error.code;
            }
          } else {
            result = {
              real: false,
              error: error
            };
          }

          message.data = {
            error: true,
            result: result
          };
          postMessage(message);
        });
        return;

      case EMIT:
        {
          var _message$data2 = message.data,
              event = _message$data2.event,
              arg = _message$data2.arg;
          emit(event, arg);
        }
        return;

      default:
        return;
    }
  };
});

var debug = false;
var log = function log() {
  var _console;

  if (!debug) {
    return;
  } // eslint-disable-next-line


  (_console = console).log.apply(_console, arguments);
};
var setDebug = function setDebug(shouldLog) {
  debug = shouldLog;
};

var partitionModel = (function (model) {
  return partitionObject(function (value) {
    return typeof value === 'function';
  }, model);
});

var owner =
/*#__PURE__*/
generateRandomId();
var instanceCounter = 0; // TODO: check if this can be reimplemented using existing @livechat/url-utils

var resolveOrigin = function resolveOrigin(url) {
  var anchor = document.createElement('a');
  anchor.href = url;

  if (anchor.origin) {
    // null (as string) might happen i.e. for "about:blank" url
    return anchor.origin === 'null' ? '*' : anchor.origin;
  }

  var protocol = anchor.protocol.length > 4 ? anchor.protocol : window.location.protocol;
  var host;

  if (anchor.host.length) {
    host = anchor.port === '80' || anchor.port === '443' ? anchor.hostname : anchor.host;
  } else {
    host = window.location.host;
  }

  return protocol + "//" + host;
};

function createIframeInstance(_ref, model) {
  var frame = _ref.frame,
      _ref$targetOrigin = _ref.targetOrigin,
      targetOrigin = _ref$targetOrigin === void 0 ? resolveOrigin(frame.src) : _ref$targetOrigin,
      _ref$handshakeRetry = _ref.handshakeRetry,
      handshakeRetry = _ref$handshakeRetry === void 0 ? {} : _ref$handshakeRetry;

  if (model === void 0) {
    model = {};
  }

  if (process.env.NODE_ENV !== 'production' && typeof handshakeRetry.interval === 'number' && handshakeRetry.interval < 500) {
    throw new Error('`handshakeRetry.interval` should be no less than 500.');
  }

  var _partitionModel = partitionModel(model),
      methods = _partitionModel[0],
      data = _partitionModel[1];

  var _createDestroyPair = createDestroyPair(),
      destroy$ = _createDestroyPair[0],
      destroy = _createDestroyPair[1];

  var instance = instanceCounter++;
  var target = frame.contentWindow;
  var emitter = mitt();

  var createMessage = function createMessage(type, payload) {
    return _createMessage(owner, instance, type, payload);
  };

  var postMessage = function postMessage(message) {
    if (process.env.NODE_ENV !== 'production') {
      log('[PARENT] sending:', JSON.stringify(message));
    }

    target.postMessage(message, targetOrigin);
  };

  var ownMessage$ = share(takeUntil(destroy$)(readme$1(function (message) {
    return message.owner === owner && message.instance === instance;
  })(getWindowMessage$())));
  var api = createApi(emitter, ownMessage$, createMessage, postMessage); // try to handshake child

  var handshake$ = share(takeUntil(destroy$)(callbagTake(1)(retry(handshakeRetry.count || 5)(timeout(handshakeRetry.interval || 500)( // we don't care about which handshake response we actually get back
  // so we pass null as requestId here
  // without it it's possible that child would respond when parent already has started a new handshake request
  // and this would cause a requestId mismatch and thus the response would get ignored
  makeRequest(ownMessage$, postMessage, createMessage(HANDSHAKE, data), null))))));

  var _messageHandler = createMessageHandler(api, emitter.emit, postMessage, methods);

  var messageHandler = process.env.NODE_ENV !== 'production' ? function (message) {
    log('[PARENT] received:', JSON.stringify(message));

    _messageHandler(message);
  } : _messageHandler; // handle incoming messages

  readme$2(messageHandler)(switchMap(function () {
    return ownMessage$;
  })(handshake$));
  return {
    api: api,
    destroy: destroy,
    handshake$: handshake$
  };
}

function connectExistingIframe(options, model) {
  var _createIframeInstance = createIframeInstance(options, model),
      api = _createIframeInstance.api,
      destroy = _createIframeInstance.destroy,
      handshake$ = _createIframeInstance.handshake$;

  return {
    destroy: destroy,
    promise: toPromise(readme(function (handshakeData) {
      api.data = handshakeData;
      api.destroy = destroy;
      return api;
    })(handshake$))
  };
}

/**
 * Debounces the given listenable source
 *
 * @param {number} wait - The number of ms to wait before letting a value pass
 * @returns {Function}
 */
function debounce(wait) {
  return function (source) {
    return function (start, sink) {
      if (start !== 0) return;
      var timeout;
      source(0, function (t, d) {
        if (t === 1 || t === 2 && d === undefined) {
          // t === 1 means the source is emitting a value
          // t === 2 and d === undefined means the source emits a completion
          if (!timeout && t === 2) {
            return sink(t, d);
          }

          if (timeout) {
            clearTimeout(timeout);
          }

          timeout = setTimeout(function () {
            sink(t, d);
            timeout = undefined;
          }, wait);
        } else sink(t, d);
      });
    };
  };
}

function connectToParent(model, _temp) {
  if (model === void 0) {
    model = {};
  }

  var _ref = _temp === void 0 ? {} : _temp,
      _ref$handshakeTimeout = _ref.handshakeTimeout,
      handshakeTimeout = _ref$handshakeTimeout === void 0 ? 3000 : _ref$handshakeTimeout;

  if (process.env.NODE_ENV !== 'production' && handshakeTimeout < 1000) {
    throw new Error('`handshakeTimeout` should be no less than 1000.');
  }

  var handshake$ = switchMap(function () {
    return callbagTake(1)(timeout(handshakeTimeout)( // this is quite bizarre, but when iframe reloads during handshake process
    // it can get "outdated" handshake (destined for the previous site)
    // even *after* receiving its own "load" event
    // we debounce here so event loop has a chance to flush all received messages
    // as the parent site might send the handshake for a new site quickly after sending one for the previos iframe site
    debounce(50)(readme$1(function (message) {
      return message.type === HANDSHAKE;
    })(getWindowMessage$()))));
  })(callbagTake(1)(getDocumentReady$())); // create & return api after handshake

  return {
    promise: toPromise(readme(function (handshake) {
      if (process.env.NODE_ENV !== 'production') {
        log('[CHILD] received handshake', JSON.stringify(handshake));
      }

      var instance = handshake.instance,
          owner = handshake.owner,
          targetOrigin = handshake.origin;

      var _partitionModel = partitionModel(model),
          methods = _partitionModel[0],
          data = _partitionModel[1];

      var target = window.parent;
      var emitter = mitt();

      var createMessage = function createMessage(type, payload) {
        return _createMessage(owner, instance, type, payload);
      };

      var postMessage = function postMessage(message) {
        if (process.env.NODE_ENV !== 'production') {
          log('[CHILD] sending:', JSON.stringify(message));
        }

        target.postMessage(message, targetOrigin);
      };

      var ownMessage$ = readme$1(function (message) {
        return message.owner === owner;
      })(getWindowMessage$());
      var api = createApi(emitter, ownMessage$, createMessage, postMessage, handshake.data);

      var _messageHandler = createMessageHandler(api, emitter.emit, postMessage, methods);

      var messageHandler = process.env.NODE_ENV !== 'production' ? function (message) {
        log('[CHILD] received:', JSON.stringify(message));

        _messageHandler(message);
      } : _messageHandler; // handle incoming messages

      readme$2(messageHandler)(ownMessage$); // send handshake reply
      // don't recycle existing object - it's used when returning api

      postMessage(_extends({}, handshake, {
        type: RESPONSE,
        data: {
          error: false,
          result: data
        }
      }));
      return api;
    })(handshake$))
  };
}

var createIframeNode = function createIframeNode(container, url) {
  var frame = document.createElement('iframe');
  container.appendChild(frame);
  frame.src = url;
  return frame;
};

function createIframe(_ref, model) {
  var container = _ref.container,
      url = _ref.url,
      options = _objectWithoutPropertiesLoose(_ref, ["container", "url"]);

  var frame = createIframeNode(container, url);
  var instance;

  var destroy = function destroy() {
    removeNode(frame);

    if (instance) {
      instance.destroy();
    }
  };

  return {
    destroy: destroy,
    frame: frame,
    promise: toPromise(callbagTake(1)(readme(function (handshakeData) {
      var _instance = instance,
          api = _instance.api;
      api.data = handshakeData;
      api.destroy = destroy;
      api.frame = frame;
      return api;
    })(switchMap(function () {
      instance = createIframeInstance(_extends({}, options, {
        frame: frame
      }), model);
      return instance.handshake$;
    })(fromEvent(frame, 'load')))))
  };
}

var create = function create(prod) {
  return function (start, sink) {
    if (start !== 0) return;

    if (typeof prod !== 'function') {
      sink(0, function () {});
      sink(2);
      return;
    }

    var end = false;
    var clean;
    sink(0, function (t) {
      if (!end) {
        end = t === 2;
        if (end && typeof clean === 'function') clean();
      }
    });

    if (end) {
      return;
    }

    clean = prod(function (v) {
      if (!end) {
        sink(1, v);
      }
    }, function (e) {
      if (!end && e !== undefined) {
        end = true;
        sink(2, e);
      }
    }, function () {
      if (!end) {
        end = true;
        sink(2);
      }
    });
  };
};

var callbagCreate = create;

var getFrame = function getFrame(frameOptions) {
  if (frameOptions.frame) {
    return frameOptions.frame;
  }

  var container = frameOptions.container,
      url = frameOptions.url;
  return createIframeNode(container, url);
};

function createReconnectableIframe(_ref, model) {
  var onConnected = _ref.onConnected,
      options = _objectWithoutPropertiesLoose(_ref, ["onConnected"]);

  var controllingFrame = !options.frame;
  var frame = getFrame(options);

  var _createDestroyPair = createDestroyPair(),
      firstInitializationDestroy$ = _createDestroyPair[0],
      firstInitializationDestroy = _createDestroyPair[1];

  var instance;

  var destroy = function destroy() {
    if (controllingFrame) {
      removeNode(frame);
    }

    if (instance) {
      instance.destroy();
    } else {
      firstInitializationDestroy();
    }
  };

  readme$2(function (api) {
    api.destroy = destroy;
    api.frame = frame;
    onConnected(api);
  })(takeUntil(firstInitializationDestroy$)( // basically we can only catch timeouts here
  // we have to retry to wait for iframe reload
  retry()(switchMap(function () {
    return callbagCreate(function (next, error) {
      var current = connectExistingIframe(_extends({}, options, {
        frame: frame
      }), model);
      current.promise.then(next, error);
      instance = current;
      return current.destroy;
    });
  })(fromEvent(frame, 'load')))));
  return {
    destroy: destroy,
    frame: frame
  };
}

export { connectExistingIframe, connectToParent, createIframe, createReconnectableIframe, setDebug };
