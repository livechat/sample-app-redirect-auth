import { noop, once, hasOwn, partitionObject, generateRandomId } from '@livechat/data-utils';
import filter from 'callbag-filter';
import flatten from 'callbag-flatten';
import fromEvent from 'callbag-from-event';
import lazy from 'callbag-lazy';
import map from 'callbag-map';
import merge from 'callbag-merge';
import share from 'callbag-share';
import defer from 'callbag-defer';
import take from 'callbag-take';
import throwError from 'callbag-throw-error';
import _extends from '@babel/runtime/helpers/esm/extends';
import toPromise from 'callbag-to-promise';
import subject from 'callbag-subject';
import promiseTry from '@livechat/promise-try';
import mitt from '@livechat/mitt';
import forEach from 'callbag-for-each';
import retry from 'callbag-retry';
import takeUntil from 'callbag-take-until';
import timeout from 'callbag-timeout';
import { debounce } from 'callbag-debounce';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { removeNode } from '@livechat/dom-utils';
import create from 'callbag-create';

var CALL = 'call';
var EMIT = 'emit';
var FINGERPRINT = '@@livechat/postmessenger';
var HANDSHAKE = 'handshake';
var RESPONSE = 'response';

var sanitizeEvent = (function (event) {
  return !!event.data && event.data[FINGERPRINT];
});

var getDocumentReady$ = function getDocumentReady$() {
  return share(filter(function () {
    return document.readyState === 'complete';
  })(merge( // just trigger a single emit so filter downstream can check if the document is ready
  lazy(noop), fromEvent(document, 'readystatechange'))));
};
var getWindowMessage$ =
/*#__PURE__*/
once(function () {
  return share(map(function (event) {
    event.data.origin = event.origin;
    return event.data;
  })(filter(sanitizeEvent)(fromEvent(window, 'message'))));
});
function switchMap(project) {
  return function (source) {
    return flatten(map(project)(source));
  };
}

var requestCounter = 0;
var makeRequest = (function (ownMessage$, postMessage, payload, request) {
  if (request === void 0) {
    request = requestCounter++;
  }

  return defer(function () {
    payload.request = request;
    postMessage(payload);
    return take(1)(switchMap(function (message) {
      if (!message.data.error) {
        // should be of(message.data.result), but don't want to add extra dependency
        // lazy is already dependency of defer
        return lazy(function () {
          return message.data.result;
        });
      }

      var _message$data$result = message.data.result,
          real = _message$data$result.real,
          error = _message$data$result.error;

      if (!real) {
        return throwError(error);
      }

      var err = new Error(error.message);

      if (hasOwn('code', error)) {
        err.code = error.code;
      }

      return throwError(err);
    })(filter(function (message) {
      return message.type === RESPONSE && message.request === request;
    })(ownMessage$)));
  });
});

var createApi = (function (emitter, ownMessage$, createMessage, postMessage, data) {
  if (data === void 0) {
    data = null;
  }

  return _extends({}, emitter, {
    call: function call(method) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return toPromise(makeRequest(ownMessage$, postMessage, createMessage(CALL, {
        method: method,
        args: args
      })));
    },
    emit: function emit(event, arg) {
      postMessage(createMessage(EMIT, {
        event: event,
        arg: arg
      }));
    },
    data: data
  });
});

function createDestroyPair() {
  var destroy$ = subject();

  var destroy = function destroy() {
    var error = new Error('Destroyed.');
    error.code = 'DESTROYED';
    destroy$(2, error);
  };

  return [destroy$, destroy];
}

var _createMessage = (function (owner, instance, type, data) {
  var _ref;

  return _ref = {}, _ref[FINGERPRINT] = true, _ref.owner = owner, _ref.instance = instance, _ref.type = type, _ref.data = data, _ref;
});

var createMessageHandler = (function (api, emit, postMessage, methods) {
  return function (message) {
    switch (message.type) {
      case CALL:
        promiseTry(function () {
          var _message$data = message.data,
              method = _message$data.method,
              args = _message$data.args;
          var fn = methods[method];
          return fn.apply(api, args);
        }).then(function (result) {
          // recycle existing object
          message.type = RESPONSE;
          message.data = {
            error: false,
            result: result
          };
          postMessage(message);
        }, function (error) {
          // recycle existing object
          message.type = RESPONSE;
          var result;

          if (error instanceof Error) {
            result = {
              real: true,
              error: {
                message: error.message
              }
            };

            if (hasOwn('code', error)) {
              result.error.code = error.code;
            }
          } else {
            result = {
              real: false,
              error: error
            };
          }

          message.data = {
            error: true,
            result: result
          };
          postMessage(message);
        });
        return;

      case EMIT:
        {
          var _message$data2 = message.data,
              event = _message$data2.event,
              arg = _message$data2.arg;
          emit(event, arg);
        }
        return;

      default:
        return;
    }
  };
});

var debug = false;
var log = function log() {
  var _console;

  if (!debug) {
    return;
  } // eslint-disable-next-line


  (_console = console).log.apply(_console, arguments);
};
var setDebug = function setDebug(shouldLog) {
  debug = shouldLog;
};

var partitionModel = (function (model) {
  return partitionObject(function (value) {
    return typeof value === 'function';
  }, model);
});

var owner =
/*#__PURE__*/
generateRandomId();
var instanceCounter = 0; // TODO: check if this can be reimplemented using existing @livechat/url-utils

var resolveOrigin = function resolveOrigin(url) {
  var anchor = document.createElement('a');
  anchor.href = url;

  if (anchor.origin) {
    // null (as string) might happen i.e. for "about:blank" url
    return anchor.origin === 'null' ? '*' : anchor.origin;
  }

  var protocol = anchor.protocol.length > 4 ? anchor.protocol : window.location.protocol;
  var host;

  if (anchor.host.length) {
    host = anchor.port === '80' || anchor.port === '443' ? anchor.hostname : anchor.host;
  } else {
    host = window.location.host;
  }

  return protocol + "//" + host;
};

function createIframeInstance(_ref, model) {
  var frame = _ref.frame,
      _ref$targetOrigin = _ref.targetOrigin,
      targetOrigin = _ref$targetOrigin === void 0 ? resolveOrigin(frame.src) : _ref$targetOrigin,
      _ref$handshakeRetry = _ref.handshakeRetry,
      handshakeRetry = _ref$handshakeRetry === void 0 ? {} : _ref$handshakeRetry;

  if (model === void 0) {
    model = {};
  }

  if (process.env.NODE_ENV !== 'production' && typeof handshakeRetry.interval === 'number' && handshakeRetry.interval < 500) {
    throw new Error('`handshakeRetry.interval` should be no less than 500.');
  }

  var _partitionModel = partitionModel(model),
      methods = _partitionModel[0],
      data = _partitionModel[1];

  var _createDestroyPair = createDestroyPair(),
      destroy$ = _createDestroyPair[0],
      destroy = _createDestroyPair[1];

  var instance = instanceCounter++;
  var target = frame.contentWindow;
  var emitter = mitt();

  var createMessage = function createMessage(type, payload) {
    return _createMessage(owner, instance, type, payload);
  };

  var postMessage = function postMessage(message) {
    if (process.env.NODE_ENV !== 'production') {
      log('[PARENT] sending:', JSON.stringify(message));
    }

    target.postMessage(message, targetOrigin);
  };

  var ownMessage$ = share(takeUntil(destroy$)(filter(function (message) {
    return message.owner === owner && message.instance === instance;
  })(getWindowMessage$())));
  var api = createApi(emitter, ownMessage$, createMessage, postMessage); // try to handshake child

  var handshake$ = share(takeUntil(destroy$)(take(1)(retry(handshakeRetry.count || 5)(timeout(handshakeRetry.interval || 500)( // we don't care about which handshake response we actually get back
  // so we pass null as requestId here
  // without it it's possible that child would respond when parent already has started a new handshake request
  // and this would cause a requestId mismatch and thus the response would get ignored
  makeRequest(ownMessage$, postMessage, createMessage(HANDSHAKE, data), null))))));

  var _messageHandler = createMessageHandler(api, emitter.emit, postMessage, methods);

  var messageHandler = process.env.NODE_ENV !== 'production' ? function (message) {
    log('[PARENT] received:', JSON.stringify(message));

    _messageHandler(message);
  } : _messageHandler; // handle incoming messages

  forEach(messageHandler)(switchMap(function () {
    return ownMessage$;
  })(handshake$));
  return {
    api: api,
    destroy: destroy,
    handshake$: handshake$
  };
}

function connectExistingIframe(options, model) {
  var _createIframeInstance = createIframeInstance(options, model),
      api = _createIframeInstance.api,
      destroy = _createIframeInstance.destroy,
      handshake$ = _createIframeInstance.handshake$;

  return {
    destroy: destroy,
    promise: toPromise(map(function (handshakeData) {
      api.data = handshakeData;
      api.destroy = destroy;
      return api;
    })(handshake$))
  };
}

function connectToParent(model, _temp) {
  if (model === void 0) {
    model = {};
  }

  var _ref = _temp === void 0 ? {} : _temp,
      _ref$handshakeTimeout = _ref.handshakeTimeout,
      handshakeTimeout = _ref$handshakeTimeout === void 0 ? 3000 : _ref$handshakeTimeout;

  if (process.env.NODE_ENV !== 'production' && handshakeTimeout < 1000) {
    throw new Error('`handshakeTimeout` should be no less than 1000.');
  }

  var handshake$ = switchMap(function () {
    return take(1)(timeout(handshakeTimeout)( // this is quite bizarre, but when iframe reloads during handshake process
    // it can get "outdated" handshake (destined for the previous site)
    // even *after* receiving its own "load" event
    // we debounce here so event loop has a chance to flush all received messages
    // as the parent site might send the handshake for a new site quickly after sending one for the previos iframe site
    debounce(50)(filter(function (message) {
      return message.type === HANDSHAKE;
    })(getWindowMessage$()))));
  })(take(1)(getDocumentReady$())); // create & return api after handshake

  return {
    promise: toPromise(map(function (handshake) {
      if (process.env.NODE_ENV !== 'production') {
        log('[CHILD] received handshake', JSON.stringify(handshake));
      }

      var instance = handshake.instance,
          owner = handshake.owner,
          targetOrigin = handshake.origin;

      var _partitionModel = partitionModel(model),
          methods = _partitionModel[0],
          data = _partitionModel[1];

      var target = window.parent;
      var emitter = mitt();

      var createMessage = function createMessage(type, payload) {
        return _createMessage(owner, instance, type, payload);
      };

      var postMessage = function postMessage(message) {
        if (process.env.NODE_ENV !== 'production') {
          log('[CHILD] sending:', JSON.stringify(message));
        }

        target.postMessage(message, targetOrigin);
      };

      var ownMessage$ = filter(function (message) {
        return message.owner === owner;
      })(getWindowMessage$());
      var api = createApi(emitter, ownMessage$, createMessage, postMessage, handshake.data);

      var _messageHandler = createMessageHandler(api, emitter.emit, postMessage, methods);

      var messageHandler = process.env.NODE_ENV !== 'production' ? function (message) {
        log('[CHILD] received:', JSON.stringify(message));

        _messageHandler(message);
      } : _messageHandler; // handle incoming messages

      forEach(messageHandler)(ownMessage$); // send handshake reply
      // don't recycle existing object - it's used when returning api

      postMessage(_extends({}, handshake, {
        type: RESPONSE,
        data: {
          error: false,
          result: data
        }
      }));
      return api;
    })(handshake$))
  };
}

var createIframeNode = function createIframeNode(container, url) {
  var frame = document.createElement('iframe');
  container.appendChild(frame);
  frame.src = url;
  return frame;
};

function createIframe(_ref, model) {
  var container = _ref.container,
      url = _ref.url,
      options = _objectWithoutPropertiesLoose(_ref, ["container", "url"]);

  var frame = createIframeNode(container, url);
  var instance;

  var destroy = function destroy() {
    removeNode(frame);

    if (instance) {
      instance.destroy();
    }
  };

  return {
    destroy: destroy,
    frame: frame,
    promise: toPromise(take(1)(map(function (handshakeData) {
      var _instance = instance,
          api = _instance.api;
      api.data = handshakeData;
      api.destroy = destroy;
      api.frame = frame;
      return api;
    })(switchMap(function () {
      instance = createIframeInstance(_extends({}, options, {
        frame: frame
      }), model);
      return instance.handshake$;
    })(fromEvent(frame, 'load')))))
  };
}

var getFrame = function getFrame(frameOptions) {
  if (frameOptions.frame) {
    return frameOptions.frame;
  }

  var container = frameOptions.container,
      url = frameOptions.url;
  return createIframeNode(container, url);
};

function createReconnectableIframe(_ref, model) {
  var onConnected = _ref.onConnected,
      options = _objectWithoutPropertiesLoose(_ref, ["onConnected"]);

  var controllingFrame = !options.frame;
  var frame = getFrame(options);

  var _createDestroyPair = createDestroyPair(),
      firstInitializationDestroy$ = _createDestroyPair[0],
      firstInitializationDestroy = _createDestroyPair[1];

  var instance;

  var destroy = function destroy() {
    if (controllingFrame) {
      removeNode(frame);
    }

    if (instance) {
      instance.destroy();
    } else {
      firstInitializationDestroy();
    }
  };

  forEach(function (api) {
    api.destroy = destroy;
    api.frame = frame;
    onConnected(api);
  })(takeUntil(firstInitializationDestroy$)( // basically we can only catch timeouts here
  // we have to retry to wait for iframe reload
  retry()(switchMap(function () {
    return create(function (next, error) {
      var current = connectExistingIframe(_extends({}, options, {
        frame: frame
      }), model);
      current.promise.then(next, error);
      instance = current;
      return current.destroy;
    });
  })(fromEvent(frame, 'load')))));
  return {
    destroy: destroy,
    frame: frame
  };
}

export { connectExistingIframe, connectToParent, createIframe, createReconnectableIframe, setDebug };
